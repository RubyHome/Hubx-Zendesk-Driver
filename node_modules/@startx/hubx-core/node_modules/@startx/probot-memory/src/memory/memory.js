"use strict";
const LongTermMemory = require("../long-term-memory/long-term-memory");
const BusinessMapping = require("../business-mapping/business-mapping");
const Context = require("../context/context");
class Memory {
    constructor() {
        this.LongTermMemory = LongTermMemory;
        this.BusinessMapping = BusinessMapping;
        this.Context = Context;
    }
    createAccount(accountType, identifier, protocol, data, organizationIdentifier) {
        return new Promise((resolve, reject) => {
            var applicationType = (['ASANA'].indexOf(accountType) > -1 ? 'CRM' : ['ZENDESK'].indexOf(accountType) > -1 ? 'HELPDESK' : ['HUBSPOT'].indexOf(accountType) > -1 ? 'CRM' : ['SALESFORCE'].indexOf(accountType) > -1 ? 'CRM' : ['GDRIVE'].indexOf(accountType) > -1 ? 'STORAGE' : ['GMAIL'].indexOf(accountType) > -1 ? 'EMAIL' : null);
            if (applicationType == 'null') {
                reject("applicationType could not be identified automatically");
            }
            BusinessMapping.account.findOrCreate({
                where: {
                    accountType,
                    identifier,
                },
                defaults: {
                    accountType,
                    applicationType,
                    protocol,
                    data,
                }
            }).then((account) => {
                resolve({
                    account: account[0]["get"]({ plain: true }),
                    created: account[1],
                });
            }).catch(reject);
        });
    }
    updateAccount(identifier, accountType, saveObj) {
        return new Promise((resolve, reject) => {
            if (!identifier || !saveObj) {
                reject("MISSING_PARAMETERS");
            }
            BusinessMapping.account.update(saveObj, {
                where: {
                    identifier,
                    accountType,
                }
            }).then((account) => {
                resolve();
            }).catch(reject);
        });
    }
    createUser(identifier, accounts, entities) {
        return new Promise((resolve, reject) => {
            if (!identifier || !accounts) {
                return reject(new Error('MISSING_PARAMETERS'));
            }
            BusinessMapping.user.findOrCreate({
                where: {
                    identifier,
                },
                defaults: {
                    accounts,
                    entities
                }
            }).then((user) => {
                resolve(user);
            }).catch(reject);
        });
    }
    mapNameEntities(accountType, accountId, entityName, nameEntities) {
        return new Promise((resolve, reject) => {
            if (!nameEntities || !accountId || !accountType || !entityName) {
                return reject(new Error('MISSING_PARAMETERS'));
            }
            if (nameEntities.length == 0) {
                return resolve();
            }
            BusinessMapping.entity.findOne({
                where: {
                    identifier: entityName,
                },
                attributes: [
                    "collectionName",
                ]
            }).then((entity) => {
                if (!entity) {
                    return reject("ENTITY_NOT_FOUND");
                }
                BusinessMapping.property.findOne({
                    where: {
                        entityIdentifier: entityName,
                        category: "ID",
                    },
                    attributes: [
                        "collectionName",
                        "identifier",
                    ]
                }).then((property) => {
                    if (!property) {
                        return reject("BUSINESS MAPPING INCORRECT MAPPING: MAIN PROPERTY WAS NOT INDEXED!");
                    }
                    var b, transactions = Math.ceil(nameEntities.length / 20), flag = 0;
                    for (b = 1; b <= transactions; b++) {
                        this.mapNameEntitiesTransaction(nameEntities, property, entity, accountId, b).then(() => {
                            flag++;
                            if (flag == transactions) {
                                resolve({
                                    collectionName: entity["collectionName"],
                                    idProperty: property["collectionName"]
                                });
                            }
                        }).catch(reject);
                    }
                }).catch(reject);
            }).catch(reject);
        });
    }
    mapNameEntitiesTransaction(nameEntities, property, entity, accountId, transactionNumber) {
        return new Promise((resolve, reject) => {
            var transaction = LongTermMemory.db.transaction();
            transaction.run((err) => {
                if (err) {
                    return reject(err);
                }
                var i;
                for (i = (transactionNumber - 1) * 20; (i < nameEntities.length && i < transactionNumber * 20); i++) {
                    if (!nameEntities[i][property["collectionName"]]) {
                        return reject("nameEntities ITEM NUMBER " + i + " DOES NOT CONTAIN THE MAIN PROPERTY FROM THE BUSINESS MAPPING (" + property["identifier"] + ")");
                    }
                    var key = LongTermMemory.db.key([entity["collectionName"], accountId + "." + nameEntities[i][property["collectionName"]]]);
                    transaction.save({
                        key,
                        data: nameEntities[i],
                    });
                }
                transaction.commit(function (err) {
                    if (err) {
                        return reject(err);
                    }
                    resolve();
                });
            });
        });
    }
    findIntents(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.intent.findAll({
                include: [
                    {
                        model: BusinessMapping.intentWord,
                        where: {
                            word: `${word}`,
                        },
                        as: "words"
                    },
                    {
                        model: BusinessMapping.intentBusinessType,
                        as: "businessTypes"
                    }
                ],
                where: {}
            }).then((intents) => {
                var i, objects = [];
                for (i = 0; i < intents.length; i++) {
                    objects.push(intents[i]["get"]({ plain: true }));
                }
                resolve(objects);
            }).catch(reject);
        });
    }
    findEntities(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.entity.findAll({
                include: [
                    {
                        model: BusinessMapping.entityWord,
                        where: {
                            word: `${word}`,
                        },
                        as: "words"
                    },
                    {
                        model: BusinessMapping.entityBusinessType,
                        as: "businessTypes"
                    }
                ],
                where: {}
            }).then((entities) => {
                var i, objects = [];
                for (i = 0; i < entities.length; i++) {
                    objects.push(entities[i]["get"]({ plain: true }));
                }
                resolve(objects);
            }).catch(reject);
        });
    }
    findNameEntities(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.entity.findAll({
                include: [
                    {
                        model: BusinessMapping.property,
                        as: "properties",
                        where: {
                            $or: [
                                {
                                    visible: true,
                                },
                                {
                                    category: "ID",
                                }
                            ]
                        }
                    },
                    {
                        model: BusinessMapping.entityBusinessType,
                        as: "businessTypes",
                    }
                ],
                attributes: [
                    "collectionName",
                    "identifier"
                ]
            }).then((records) => {
                if (!records.length) {
                    return resolve([]);
                }
                var i, entities = [];
                for (i = 0; i < records.length; i++) {
                    entities.push(records[i]["get"]({ plain: true }));
                }
                var i, results = [], flag = 0;
                for (i = 0; i < entities.length; i++) {
                    this.getNameEntities(entities[i], word).then(records => {
                        flag++;
                        if (records) {
                            results = results.concat(records);
                        }
                        if (flag == entities.length) {
                            resolve(results);
                        }
                    }).catch(reject);
                }
            }).catch(reject);
        });
    }
    findNameEntitiesDifference(entityIdentifier, accountLogon, map) {
        return new Promise((resolve, reject) => {
            if (!entityIdentifier || !map || !Object.keys(map).length) {
                return reject("MISSING_PARAMETERS");
            }
            BusinessMapping.entity.findOne({
                include: [
                    {
                        model: BusinessMapping.property,
                        as: "properties",
                        where: {
                            category: "ID",
                        },
                        attributes: [
                            "collectionName"
                        ]
                    },
                ],
                where: {
                    identifier: entityIdentifier,
                },
                attributes: [
                    "collectionName"
                ],
            }).then((entity) => {
                if (!entity) {
                    return reject("NOT_FOUND");
                }
                if (!entity["properties"].length) {
                    return reject("NO ID PROPERTY FOUND ON ENTITY " + entityIdentifier);
                }
                var transaction = LongTermMemory.db.transaction();
                transaction.run(function (err) {
                    if (err) {
                        return reject(err);
                    }
                    var keys = [];
                    var i;
                    for (i in map) {
                        keys.push(LongTermMemory.db.key([entity["collectionName"], accountLogon + "." + i]));
                    }
                    transaction.get(keys, function (err, records) {
                        if (!records) {
                            resolve();
                        };
                        var difference = {}, b;
                        for (i = 0; i < records.length; i++) {
                            difference[records[i][entity["properties"][0].collectionName]] = {};
                            for (b in map[records[i][entity["properties"][0].collectionName]]) {
                                if (typeof records[i][b] == undefined || records[i][b] != map[records[i][entity["properties"][0].collectionName]][b]) {
                                    difference[records[i][entity["properties"][0].collectionName]][b] = map[records[i][entity["properties"][0].collectionName]][b];
                                }
                            }
                        }
                        resolve(difference);
                    });
                });
            }).catch(reject);
        });
    }
    getNameEntities(entity, word) {
        return new Promise((resolve, reject) => {
            if (!entity["properties"].length) {
                return resolve();
            }
            var idProperty;
            for (i = 0; i < entity["properties"].length; i++) {
                if (entity["properties"][i].category == 'ID') {
                    idProperty = entity["properties"][i].collectionName;
                    entity["properties"].splice(i, 1);
                    break;
                }
            }
            if (!idProperty) {
                return reject("BUSINESS MAP ERROR: NO ID PROPERTY FOR ENTITY " + entity["identifier"]);
            }
            var i, query, records = [];
            query = LongTermMemory.db.createQuery(entity["collectionName"]);
            LongTermMemory.db.runQuery(query).then((results) => {
                results = results[0];
                if (!results.length) {
                    return resolve();
                }
                else {
                    var b;
                    for (b = 0; b < results.length; b++) {
                        for (i = 0; i < entity["properties"].length; i++) {
                            if (new RegExp(word, "ig").test(results[b][entity["properties"][i].collectionName])) {
                                records.push(results[b]);
                                break;
                            }
                        }
                    }
                }
                if (!records.length) {
                    return resolve();
                }
                resolve({
                    entityIdentifier: entity["identifier"],
                    businessType: entity["businessType"],
                    idProperty,
                    records,
                });
            }).catch(reject);
        });
    }
    findProperties(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.property.findAll({
                include: [
                    {
                        model: BusinessMapping.propertyWord,
                        where: {
                            word: `${word}`,
                        },
                        as: "words"
                    },
                    {
                        model: BusinessMapping.propertyBusinessType,
                        as: "businessTypes"
                    }
                ],
                where: {}
            }).then((properties) => {
                var i, objects = [];
                for (i = 0; i < properties.length; i++) {
                    objects.push(properties[i]["get"]({ plain: true }));
                }
                resolve(objects);
            }).catch(reject);
        });
    }
    findStaticProperties(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.property.findAll({
                include: [
                    {
                        model: BusinessMapping.propertyValue,
                        as: "values",
                        include: [
                            {
                                model: BusinessMapping.propertyValueWords,
                                as: "words",
                                where: {
                                    word: `${word}`,
                                },
                            },
                        ]
                    },
                    {
                        model: BusinessMapping.propertyBusinessType,
                        as: "businessTypes"
                    }
                ],
                where: {}
            }).then((properties) => {
                var i, objects = [];
                for (i = 0; i < properties.length; i++) {
                    objects.push(properties[i]["get"]({ plain: true }));
                }
                resolve(objects);
            }).catch(reject);
        });
    }
    findVirtualObjects(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.virtualObject.findAll({
                include: [
                    {
                        model: BusinessMapping.virtualObjectWord,
                        where: {
                            word: `${word}`,
                        },
                        as: "words"
                    },
                    {
                        model: BusinessMapping.virtualObjectBusinessType,
                        as: "businessTypes"
                    }
                ],
                where: {}
            }).then((virtualObjects) => {
                var i, objects = [];
                for (i = 0; i < virtualObjects.length; i++) {
                    objects.push(virtualObjects[i]["get"]({ plain: true }));
                }
                resolve(objects);
            }).catch(reject);
        });
    }
    findSkills(word) {
        return new Promise((resolve, reject) => {
            BusinessMapping.skill.findAll({
                include: [
                    {
                        model: BusinessMapping.skillWord,
                        where: {
                            word: `${word}`,
                        },
                        as: "words"
                    },
                    {
                        model: BusinessMapping.skillBusinessType,
                        as: "businessTypes"
                    }
                ],
                where: {}
            }).then((skills) => {
                var i, objects = [];
                for (i = 0; i < skills.length; i++) {
                    objects.push(skills[i]["get"]({ plain: true }));
                }
                resolve(objects);
            }).catch(reject);
        });
    }
    findPersonalityTexts(variableNames, personalityIdentifier, mood) {
        return new Promise((resolve, reject) => {
            if (!mood) {
                Context.personality.findOne({
                    where: {
                        identifier: personalityIdentifier,
                    },
                    attributes: [
                        "defaultMood"
                    ]
                }).then(personality => {
                    if (!personality) {
                        return reject("NO PERSONALITY FOUND");
                    }
                    this.findPersonalityTextFinal(variableNames, personalityIdentifier, personality["defaultMood"]).then(resolve).catch(reject);
                }).catch(reject);
            }
            else {
                this.findPersonalityTextFinal(variableNames, personalityIdentifier, mood).then(resolve).catch(reject);
            }
        });
    }
    findPersonalityTextFinal(variableNames, personalityIdentifier, mood) {
        return new Promise((resolve, reject) => {
            Context.personalityText.findAll({
                where: {
                    mood,
                    personalityIdentifier,
                    variableName: {
                        $in: variableNames
                    },
                },
                attributes: [
                    "variableName",
                    "text",
                    "probability"
                ]
            }).then((texts) => {
                if (!texts.length) {
                    return resolve();
                }
                var i, map = new Map(), b;
                for (i = 0; i < texts.length; i++) {
                    if (!map[texts[i]["variableName"]]) {
                        map[texts[i]["variableName"]] = [];
                    }
                    for (b = 0; b < texts[i]["probability"]; b++) {
                        map[texts[i]["variableName"]].push(texts[i]["text"]);
                    }
                }
                for (i in map) {
                    map[i] = map[i][Math.floor(Math.random() * map[i].length)];
                }
                resolve(map);
            }).catch(reject);
        });
    }
}
exports.Memory = Memory;
